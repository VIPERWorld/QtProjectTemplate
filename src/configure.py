#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This script requires Python >= 2.6. I has been tested with Python 2.7.6 on
# Ubuntu and Windows. It has not yet been tested with Python 3, or on MacOS,
# but might just work.

# NOTE: If you edit this file, then you must manually call
#       qmake for changes to take effect

# Documentation
# -------------
#
# For each project file in the distribution:
#
#     src/Path/To/Project/Project.pro
#
# This script automatically generates an additional project file:
#
#     <build-directory>/Path/To/Project/.config.pri
#
# Which is included by Project.pro.
#
# The automatically generated .config.pri files contain all the boilerplate
# that should normally be manually written in Project.pro, but that can be
# automated, such as:
#
#     1. Specify common configuration options (e.g., C++11 compiler flag)
#
#     2. Set INCLUDEPATH, DEPENDPATH, PRE_TARGETDEPS, and LIBS variables for
#        all platforms, based on the DEPENDS variable of the current project.
#
#     3. Set the SUBDIRS dependencies based on the DEPENDS variable of
#        subprojects
#

#--------------------------- Required modules ---------------------------------

# Built-in modules
import sys
import os
import shutil
import errno
import re

# Curstom module
import buildutils

#--------------- Arguments passed to this script by qmake ---------------------

# <root-dir>/src directory (directory that contains this script)
srcDir = sys.argv[1]

# <root-dir>/tests directory
testsDir = srcDir[:-3] + "tests"

# <build-dir>/src/ directory
outDir = sys.argv[2]
outTestsDir = outDir[:-3] + "tests"

# QMake Config
qmakeConfig = sys.argv[3:]


#---------------------------- Config texts ------------------------------------

headerText = """
# This file is automatically generated and lives in the build directory.
# Any edit will be lost.
"""

makelibtestsText = """
# Make default unit tests for new header files
win32: PYTHON=python.exe
else:  PYTHON=python
system($$PYTHON %1/makelibtests.py %1 $$_PRO_FILE_PWD_ $$OUT_PWD $$CONFIG)
"""
makelibtestsText = makelibtestsText.replace('%1', srcDir)

makesubdirstestsText = """
# Make default unit tests for new libraries
win32: PYTHON=python.exe
else:  PYTHON=python
system($$PYTHON %1/makesubdirstests.py %1 $$_PRO_FILE_PWD_ $$OUT_PWD $$CONFIG)
"""
makesubdirstestsText = makesubdirstestsText.replace('%1', srcDir)

enableCpp11Text = """
# Enable C++11
CONFIG += c++11
"""

prlText = """
# Tell qmake to create a .prl file for this library, and to use it when linking
# against this library. This allows any application that links against this
# library to also link against all libraries that this library depends on.
# I think this is useless since configure.py already computes recursively
# the dependencies and pass them all to the linker in the proper order, but
# to be honest, I don't understand 100% what these .prl files do and it doesn't
# hurt to keep them.
CONFIG += create_prl link_prl
"""

staticLibText = """
# Compile as a static library
CONFIG += staticlib
"""

includeText = """
# Add src/libs/ and src/third/ to INCLUDEPATH.
# This fixes "cannot find MyLib/MyHeader.h" compile errors.
INCLUDEPATH += %1/libs/
INCLUDEPATH += %1/third/
unix: QMAKE_CXXFLAGS += $$QMAKE_CFLAGS_ISYSTEM %1/libs/
unix: QMAKE_CXXFLAGS += $$QMAKE_CFLAGS_ISYSTEM %1/third/

# Add src/libs/ and src/third/ to DEPENDPATH.
# This causes to re-compile dependent .cpp files in this project, whenever
# dependee .h files in src/ are modified. In Qt5, this is redundant with adding
# src/ to INCLUDEPATH, but we keep it for documentation and compatibility with
# Qt4.
DEPENDPATH += %1/libs/
DEPENDPATH += %1/third/
"""
includeText = includeText.replace('%1', srcDir)

releaseOrDebugText = """
# Convenient variable whose value is "release" when building
# in release mode, and "debug" when building in debug mode
CONFIG(release, debug|release): RELEASE_OR_DEBUG = release
CONFIG(debug,   debug|release): RELEASE_OR_DEBUG = debug
"""


#------------- text to add a lib this project depends on ----------------------

# Usage:
#     %1: must be replaced by the dependent lib project's name
#     %2: must be replaced by the dependent lib project's srcDir
#     %3: must be replaced by the dependent lib project's outDir

addLibText = """
# Add %1 to LIBS.
# This fixes "undefined reference to `%1::MyFunction()'" linking errors.
unix:  LIBS += -L%3/ -l%1
win32: LIBS += -L%3/$$RELEASE_OR_DEBUG/ -l%1

# Add %1 to PRE_TARGETDEPS.
# This causes to re-link against %1 whenever %1 is recompiled (for instance,
# due a modification of a .cpp file in %1).
unix:       PRE_TARGETDEPS += %3/lib%1.a
win32-g++:  PRE_TARGETDEPS += %3/$$RELEASE_OR_DEBUG/lib%1.a
else:win32: PRE_TARGETDEPS += %3/$$RELEASE_OR_DEBUG/%1.lib
"""


#---------- Project class to store info parsed from the .pro files ------------

# Project class
class Project:

    def __init__(self):

        # Project-related directories and filenames

        self.name = ""      # Project
        self.filename = ""  # Project.pro

        self.relDir = ""    # Path/To/Project
        self.relPath = ""   # Path/To/Project/Project.pro

        self.srcDir = ""    # /home/user/QtProjectTemplate/src/Path/To/Project
        self.srcPath = ""   # /home/user/QtProjectTemplate/src/Path/To/Project/Project.pro

        self.outDir = ""    # /home/user/QtProjectTemplate/build-Qt_5_5_GCC_64bit-Debug/Path/To/Project
        self.outPath = ""   # /home/user/QtProjectTemplate/build-Qt_5_5_GCC_64bit-Debug/Path/To/Project/.config.pri

        # Data parsed from project files

        self.template = ""  # subdirs | lib | app
        self.depends  = []  # Examples:
                            #     []                 for src/Core/Core.pro            (lib)
                            #     [ "Core" ]         for src/Gui/Widgets/Widgets.pro  (lib)
                            #     [ "Gui/Widgets" ]  for src/Gui/Windows/Windows.pro  (lib)
                            #     [ "Gui/Windows" ]  for src/App/App.pro              (app)
                            #     []                 for src/Gui/Gui.pro              (subdirs)
                            #     []                 for src/QtProjectTemplate.pro    (subdirs)
        self.subdirs  = []  # Examples:
                            #     []                        for src/Core/Core.pro            (lib)
                            #     []                        for src/Gui/Widgets/Widgets.pro  (lib)
                            #     []                        for src/Gui/Windows/Windows.pro  (lib)
                            #     []                        for src/App/App.pro              (app)
                            #     [ "Widgets", "Windows"]   for src/Gui/Gui.pro              (subdirs)
                            #     [ "Core", "Gui", "App" ]  for src/QtProjectTemplate.pro    (subdirs)

        # Transitive closure of the .depends relationship

        self.tDependsIsComputed      = False  # Prevent computing more than once
        self.tDependsIsBeingComputed = False  # Detect cyclic dependencies
        self.tDepends = set()                 # Examples:
                                              #     {}                                        for src/Core/Core.pro            (lib)
                                              #     { "Core" }                                for src/Gui/Widgets/Widgets.pro  (lib)
                                              #     { "Gui/Widgets", "Core" }                 for src/Gui/Windows/Windows.pro  (lib)
                                              #     { "Gui/Windows" ,"Core", "Gui/Widgets" }  for src/App/App.pro              (app)
                                              #     {]                                        for src/Gui/Gui.pro              (subdirs)
                                              #     {]                                        for src/QtProjectTemplate.pro    (subdirs)

        # Same as tDepends, but ordered via topological sort
        # This specifies the order in which libs should be linked against.

        self.sDepends = []  # Examples:
                            #     []                                        for src/Core/Core.pro            (lib)
                            #     [ "Core" ]                                for src/Gui/Widgets/Widgets.pro  (lib)
                            #     [ "Core", "Gui/Widgets" ]                 for src/Gui/Windows/Windows.pro  (lib)
                            #     [ "Core", "Gui/Widgets", "Gui/Windows" ]  for src/App/App.pro              (app)
                            #     []                                        for src/Gui/Gui.pro              (subdirs)
                            #     []                                        for src/QtProjectTemplate.pro    (subdirs)

        # Parent/child relationship between projects

        self.parentProject = None
        self.subProjects = []

        # Subdir info dependencies
        # This specifies the order in which subprojects should be built.

        self.subdir    = ""             # To/Project ( = dir of this project relative to parent project)
        self.subdirKey = ""             # To_Project ( = key to identify this subdir without using slashes)
        self.subdirDependsKeys = set()  # Examples:
                                        #     {}                 for src/Core/Core.pro            (lib)
                                        #     {}                 for src/Gui/Widgets/Widgets.pro  (lib)
                                        #     { "Widgets" }      for src/Gui/Windows/Windows.pro  (lib)
                                        #     { "Core", "Gui" }  for src/App/App.pro              (app)
                                        #     { "Core" }         for src/Gui/Gui.pro              (subdirs)
                                        #     {}                 for src/QtProjectTemplate.pro    (subdirs)

# Dictionary storing all projects in the distribution, accessed by their relDir
#
# Example:
#     {
#         ""            : <Project instance> ,
#         "Core"        : <Project instance> ,
#         "Gui/Widgets" : <Project instance> ,
#         "Gui/Windows" : <Project instance> ,
#         "App"         : <Project instance>
#     }
#
projects = {}

# Returns the project corresponding to the given libname.
# libname is the path of the library relative to third/ or libs/.
# Examples:
#     Core
#     Gui/Widgets
#     Gui/Windows
#     Geometry
def getLibProject(libname):
    if ("third/" + libname) in projects:
        libProject = projects[("third/" + libname)]
    elif ("libs/" + libname) in projects:
        libProject = projects[("libs/" + libname)]
    else:
        libProject = None
        print ("Error: dependent library", libRelDir, "not found. Note: you can only " +
               "depends on 'TEMPLATE = lib' subprojects, maybe you tried to depend on " +
               "a 'TEMPLATE = app' subproject?")
    return libProject


#----------------------------- Actual script ----------------------------------

# Write QMake CONFIG value in a file. This is used by tests, so they can link
# against libraries build with the same config. If no folder is found containing
# the same config, then it will create it.

# Find all project files
for x in os.walk(srcDir):
    dirname = x[0].replace('\\', '/') # manually replace backslashes with slashes for Windows
    filenames = x[2]
    relativeDirname = dirname[len(srcDir)+1:]
    for filename in filenames:
        if filename.endswith('.pro'):
            # Create project object
            project = Project()
            project.filename = filename   # "Project.pro"
            project.name = filename[:-4]  # "Project"

            # Get path of directory relative to the root of the distribution
            # This path is used as key to identified the project.
            project.relDir = dirname[len(srcDir)+1:]  # "Path/To/Project"

            # Get relPath, srcDir, and outDir (special case of root project)
            if project.relDir == "":
                project.relPath = project.filename  # "QtProjectTemplate.pro"
                project.srcDir  = srcDir            # "/home/user/QtProjectTemplate/src"
                project.outDir  = outDir            # "/home/user/QtProjectTemplate/build-Qt_5_5_GCC_64bit-Debug"

            # Get relPath, srcDir, and outDir (normal case of non-root project)
            else:
                project.relPath = project.relDir + '/' + project.filename  # "Path/to/Project/Project.pro"
                project.srcDir = srcDir + '/' + project.relDir             # "/home/user/QtProjectTemplate/src/Path/to/Project"
                project.outDir = outDir + '/' + project.relDir             # "/home/user/QtProjectTemplate/build-Qt_5_5_GCC_64bit-Debug/Path/To/Project"

            # Get srcPath and outPath
            project.srcPath = project.srcDir + '/' + project.filename  # "/home/user/QtProjectTemplate/src/Path/to/Project/Project.pro"
            project.outPath = project.outDir + '/.config.pri'          # "/home/user/QtProjectTemplate/build-Qt_5_5_GCC_64bit-Debug/Path/To/Project/.config.pri"

            # Insert in dictionary storing all projects, using relDir as the key
            projects[project.relDir] = project


# Parse projects
for relDir in projects:
    # Get project
    project = projects[relDir]

    # Get project file as string
    data = buildutils.readFromFile(project.srcPath)

    # Parse TEMPLATE value
    project.template = buildutils.getTemplate(data)

    # Parse DEPENDS value
    project.depends = buildutils.getDepends(data)

    # Parse SUBDIRS value
    project.subdirs = buildutils.getSubdirs(data)


# Helper method:
#
# Computes the transitive closure of project.depends
# and store it in project.tDepends.
#
# What makes this recursive function terminate is
# that for libs which do not depend on any other
# libs, then len(project.depends) == 0 and therefore
# there is no recursion.
#
# Cyclic dependencies are detected and reported as an error.
#
def computeTDepends(project):
    # Do nothing if already computed
    if project.tDependsIsComputed:
        pass

    # Detect cyclic dependencies
    if project.tDependsIsBeingComputed:
        print "Error:", project.name, "has a cyclic dependency."
        pass

    # Mark as being computed
    project.tDependsIsBeingComputed = True

    # Compute
    project.tDepends = set(project.depends)
    for libname in project.depends:
        libProject = getLibProject(libname)
        computeTDepends(libProject)
        project.tDepends = project.tDepends.union(libProject.tDepends)

    # Mark as computedSet isComputed
    project.tDependsIsBeingComputed = False
    project.tDependsIsComputed = True


# Compute the transitive closure of all projects .depends
for relDir in projects:
    # Get project
    project = projects[relDir]

    # Compute tDepends
    computeTDepends(project)


# Compare method for topological sort
def dependsOn(libname1, libname2):
    libProject1 = getLibProject(libname1)
    libProject2 = getLibProject(libname2)
    if libname1 in libProject2.tDepends:
        return -1
    elif libname2 in libProject1.tDepends:
        return +1
    else:
        return 0

# Compute a topological sort to have all transitive dependencies listed in
# order (If lib1 depends on lib2, then lib1 appears after lib1 in the list)
for relDir in projects:
    # Get project
    project = projects[relDir]

    # Compute topological sort
    tDepends = list(project.tDepends)
    project.sDepends = sorted(tDepends, cmp=dependsOn)


# Set parent/child relationships
for relDir in projects:
    # Get project
    project = projects[relDir]

    # For all subdir in subdirs
    for subdir in project.subdirs:
        # Get relDir of subproject
        if project.relDir == "":
            subProjectRelDir = subdir                         # "App"
        else:
            subProjectRelDir = project.relDir + '/' + subdir  # "Gui" + '/' + "src/Gui"

        # Check if subProject exists
        if subProjectRelDir in projects:
            # Get subproject
            subProject = projects[subProjectRelDir]

            # Set parent/child relationships
            project.subProjects.append(subProject)
            subProject.parentProject = project
            subProject.subdir = subdir
            subProject.subdirKey = subdir.replace('/', '__')

        else:
            print ("Error: subproject", subProjectRelDir, "of project", project.relDir, "not found.")


# Helper method:
#
# Returns a list of all ancestors of a project. The first element of the
# returned list is the root project of the distribution, and the last element
# is the given project.
#
def getAncestors(project):
    ancestors = [project]
    while ancestors[0].parentProject != None:
        ancestors.insert(0, ancestors[0].parentProject)
    return ancestors


# Resolve subdirs dependencies based on lib/app dependencies
for relDir in projects:
    # Get project
    project = projects[relDir]

    # For all lib/app dependency
    for libname in project.sDepends:
        # Get project of the lib this project depends on
        libProject = getLibProject(libname)

        # Get all ancestors of this project and of libProject
        projectAncestors = getAncestors(project)
        libProjectAncestors = getAncestors(libProject)

        # Find common ancestor
        indexCommonAncestor = 0
        while projectAncestors[indexCommonAncestor+1] == libProjectAncestors[indexCommonAncestor+1]:
            indexCommonAncestor += 1

        # Add subdir dependency
        dependentProject = projectAncestors[indexCommonAncestor+1]
        dependeeProject  = libProjectAncestors[indexCommonAncestor+1]
        dependentProject.subdirDependsKeys.add(dependeeProject.subdirKey)


# Generate all .config.pri files
for relDir in projects:
    # Get project
    project = projects[relDir]

    # Content to write to .config.pri
    content = ""

    # Write header
    content += headerText

    # Write python calls that generates unit tests
    if project.relDir.startswith('libs'):
        if project.template == "lib":
            content += makelibtestsText
        elif project.template == "subdirs":
            content += makesubdirstestsText

    # Enable C++11
    if project.template == "lib" or project.template == "app":
        content += enableCpp11Text

    # Insert PRL config lines
    if project.template == "lib" or project.template == "app":
        content += prlText

    # Adds all headers of the distribution in include path
    if project.template == "lib" or project.template == "app":
        content += includeText

    # Compile as a static library
    if project.template == "lib":
        content += staticLibText

    # If project is a subdir
    if project.template == "subdirs":
        # Override value of SUBDIRS by using keys instead of folder path
        subdirsText = ("\n" +
                       "# Override value of SUBDIRS by using keys instead of folder path\n" +
                       "SUBDIRS =")
        for subProject in project.subProjects:
            subdirsText += " \\\n    " + subProject.subdirKey
        subdirsText += "\n"
        content += subdirsText

        # Set subdirs and dependencies
        for subProject in project.subProjects:
            subdirText = ("\n" +
                          "# Set " + subProject.subdirKey + " location and dependencies\n")
            subdirText += subProject.subdirKey + ".subdir  = " + subProject.subdir + "\n"
            subdirText += subProject.subdirKey + ".depends ="
            for key in subProject.subdirDependsKeys:
                subdirText += " " + key
            subdirText += "\n"
            content += subdirText

    # Add text required whenever there is at least one lib dependency
    if len(project.sDepends) > 0:
        content += releaseOrDebugText

    # Add each dependent lib in order
    # Note that we use the reversed topological order since
    # each library must appear in the linker command line *before* the
    # libraries they depend on. This is counter-intuitive, but that's how it is.
    #
    for libname in reversed(project.sDepends):
        libProject = getLibProject(libname)
        addThisLib = (addLibText.replace('%1', libProject.name)
                                .replace('%2', libProject.srcDir)
                                .replace('%3', libProject.outDir))
        content += addThisLib

    # Writes content to .config.pri
    buildutils.writeToFileIfDifferent(project.outPath, content)
